{"version":3,"sources":["../webpack/bootstrap 4846813cab689b394536","ai.worker.ts","Util.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","value","__WEBPACK_IMPORTED_MODULE_0__Util__","addEventListener","event","aiColumn","aiMove","data","board","depth","aiMark","postMessage","colIx","Util","dumpBoard","numRows","numCols","dump","rowIx","console","log","stringifyBoard","str","checkForWinner","columnWinner","checkColumnsForWinner","rowWinner","checkRowsForWinner","diagonalWinner","checkDiagonalForWinner","winner","isBoardFull","_i","board_1","length","column","board_2","_a","column_1","isValidMove","column_2","getNumOccurences","segment","token","numTokens","cellIx","evaluateBoardFor","maximizerToken","score","segments","segmentBoard","playerId","opponentId","segments_1","numPlayer","numOpponent","evaluateBoardForV2","segments_2","scanLines_1","scanBoard","scanLine","push","scanLines","row","col","startRow","startCol","deltaRow","deltaCol","nextCellRow","nextCellCol","nextCell","nextMoves","columnIxs","ix","indexOf","nextMovesReverse","nextMovesCenterFirst","isGameOver","segments_3","isFull","board_3","deepcopyBoard","newBoard","Array","from","moveOnBoard","columnIx","moveOnBoardWithoutCopy","unmoveOnBoardWithoutCopy","minimax","isMaximizer","memo","stats","key","JSON","stringify","val","undefined","hitCount","Infinity","nextMoves_1","move","returnValue","nextMoves_2","minimizerToken","minimax_search","nextMoves_3","sortListByMiddle","list","newList","middleIx","Math","floor","leftIx","rightIx","leftDone","rightDone","sortListByDistanceToColumnIndex3","sort","a","b","abs","alphabeta","alpha","beta","isMaximizingPlayer","maximizerId","evalFn","nextMovesFn","copyBoard","numAlphaBetaCalled","has","numEvals","set","nextMoves_4","nextMove","boardToWorkOn","valueReturned","max","nextMoves_5","minimizerId","min","alphabetaSearch","aiToken","Map","progress","nextMoves_6"],"mappings":"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","file":"4846813cab689b394536.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/connect4-ai/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4846813cab689b394536","import Util from './Util'\r\n\r\n// console.log('ai.worker.ts !!!')\r\n\r\n// Post data to parent thread\r\n//postMessage({ foo: 'foo' });\r\n\r\n// Respond to message from parent thread\r\naddEventListener('message', (event) => {\r\n    // console.log('worker received message from main thread')\r\n    // console.log(event.data)\r\n    const aiColumn = Util.aiMove(event.data.board, event.data.depth, event.data.aiMark)\r\n    postMessage({colIx: aiColumn})\r\n});\n\n\n// WEBPACK FOOTER //\n// ./src/ai.worker.ts","class Util {\r\n    public static dumpBoard(board:string[][], numRows:number, numCols:number) {\r\n        //console.log(`dumpBoard(${board})`)\r\n        let dump:string = ''\r\n        for (let rowIx = 0; rowIx < numRows; rowIx++) {\r\n            for(let colIx = 0; colIx < numCols; colIx++) {\r\n                dump += (board[colIx][rowIx] === '') ? '.' : board[colIx][rowIx]            \r\n                if (colIx === numCols-1) {\r\n                    dump += '\\n'\r\n                }\r\n            }\r\n        }\r\n        console.log(dump)\r\n    }\r\n\r\n    public static stringifyBoard(board:string[][], numRows:number, numCols:number) {\r\n        //console.log(`dumpBoard(${board})`)\r\n        let str:string = ''\r\n        for (let rowIx = 0; rowIx < numRows; rowIx++) {\r\n            for(let colIx = 0; colIx < numCols; colIx++) {\r\n                str += (board[colIx][rowIx] === '') ? '.' : board[colIx][rowIx]            \r\n                if (colIx === numCols-1) {\r\n                    str += '\\n'\r\n                }\r\n            }\r\n        }\r\n        return str\r\n    }\r\n\r\n    public static checkForWinner(board:string[][]) {\r\n//        console.log('checkForWinner()')\r\n        const columnWinner =  Util.checkColumnsForWinner(board)\r\n        const rowWinner = Util.checkRowsForWinner(board)\r\n        const diagonalWinner = Util.checkDiagonalForWinner(board)\r\n        let winner = ''\r\n        if(columnWinner !== '') {\r\n            winner = columnWinner\r\n        } else if(rowWinner !== '') {\r\n            winner = rowWinner\r\n        } else if(diagonalWinner !== '') {\r\n            winner = diagonalWinner\r\n        } else {\r\n            if(Util.isBoardFull(board)) {\r\n                winner = 'tie'\r\n            }\r\n        }\r\n        return winner\r\n    }\r\n\r\n    private static checkColumnsForWinner(board:string[][]) {\r\n        for(const column of board) {\r\n            for(let i = 0; i < column.length-3; i++) {\r\n                if(column[i] === column[i+1] && column[i+1] === column[i+2] && column[i+2] === column[i+3] && column[i] !== '') {\r\n//                    console.log('column[i]:' + column[i])\r\n                    return column[i]\r\n                }\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    private static checkRowsForWinner(board:string[][]) {\r\n        for(let colIx = 0; colIx < board.length-3; colIx++) {\r\n            for(let rowIx = 0; rowIx < board[colIx].length; rowIx++) {\r\n                if(\r\n                    board[colIx][rowIx] === board[colIx+1][rowIx] &&\r\n                    board[colIx+1][rowIx] === board[colIx+2][rowIx] &&\r\n                    board[colIx+2][rowIx] === board[colIx+3][rowIx] &&\r\n                    board[colIx][rowIx] !== '') {\r\n                        return board[colIx][rowIx]\r\n                    }\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    private static checkDiagonalForWinner(board:string[][]) {\r\n        for(let colIx = 0; colIx < board.length-3; colIx++) {\r\n            for(let rowIx = 0; rowIx < board[colIx].length-3; rowIx++) {\r\n                if(board[colIx][rowIx] === board[colIx+1][rowIx+1] &&\r\n                        board[colIx+1][rowIx+1] === board[colIx+2][rowIx+2] &&\r\n                        board[colIx+2][rowIx+2] === board[colIx+3][rowIx+3] &&\r\n                        board[colIx][rowIx] !== '') {\r\n                    return board[colIx][rowIx]\r\n                }\r\n            }\r\n\r\n            for(let rowIx = 3; rowIx < board.length; rowIx++) {\r\n                if(board[colIx][rowIx] === board[colIx+1][rowIx-1] &&\r\n                board[colIx+1][rowIx-1] === board[colIx+2][rowIx-2] &&\r\n                board[colIx+2][rowIx-2] === board[colIx+3][rowIx-3] &&\r\n                board[colIx][rowIx] !== '') {\r\n                    return board[colIx][rowIx]    \r\n                }\r\n\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    public static isBoardFull(board:string[][]) {\r\n        for(const column of board) {\r\n            for(const cell of column) {\r\n                if(cell === '') return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    public static isValidMove(column:string[]) {\r\n        for(const cell of column) {\r\n            if(cell === '') {\r\n//                console.log('isValidMove TRUE')\r\n                return true\r\n            }\r\n        }\r\n//        console.log('isValidMove FALSE')\r\n        return false\r\n    }\r\n\r\n//     def segment_evaluate_v2(board, maximizer_id=0):\r\n//     '''\r\n//     3-in-a-row would give a score of 9, 2 would be 4, 1=1) and if state\r\n//     resulted in 4 in a row it would get a big bonus/punishment of\r\n//     10000/-10000. \r\n//     '''\r\n//     global segment_evaluate_v2_callcount\r\n//     segment_evaluate_v2_callcount += 1\r\n//     score = 0\r\n//     segments = segment_board(board)\r\n\r\n//     player_id = 0\r\n//     if maximizer_id != 0:\r\n//         player_id = maximizer_id\r\n//     else:\r\n//         player_id = board.get_current_player_id()\r\n    \r\n//     opponent_id = 1 if player_id == 2 else 2\r\n\r\n//     #print 'player_id:', player_id\r\n//     #print 'opponent_id:', opponent_id\r\n//     #print segments\r\n// #    print 'seglen:', len(segments)\r\n//     for segment in segments:\r\n// #        print 'seg:', segment\r\n//         num_player = [i for i, x in enumerate(segment) if x == player_id]\r\n//         num_opponent = [i for i, x in enumerate(segment) if x == opponent_id]\r\n//         num_empty = [i for i, x in enumerate(segment) if x == 0]\r\n//         # loop through indexes of segment and push into arrays depending on value\r\n//         # num_empty = [i for i, x in enumerate(segment) if x == 0]\r\n//         # num_x = [i for i, x in enumerate(segment) if x == 1]\r\n//         # num_o = [i for i, x in enumerate(segment) if x == 2]\r\n// #        print 'numx:', num_x\r\n// #        print 'numo:', num_o\r\n// #        print 'nume:', num_empty\r\n// #        print '_______________'\r\n//         if len(num_opponent) == 0:\r\n//             if len(num_player) > 0:\r\n//                 if len(num_player) == 4:\r\n//                    score += 10000\r\n//                 else:\r\n//                     score += len(num_player) * len(num_player)\r\n// #                print 'score:', len(num_x) * len(num_x)\r\n\r\n//         if len(num_player) == 0:\r\n//             if len(num_opponent) > 0:\r\n//                 if len(num_opponent) == 4:\r\n//                     score -= 10000\r\n//                 else:\r\n//                     score -= len(num_opponent) * len(num_opponent)\r\n// #                print 'score:', len(num_o) * len(num_o)\r\n\r\n//     # print 'turn:', board.get_current_player_id()\r\n//     # print board\r\n//     #print 'score:', score\r\n//     # print '_____________________'\r\n//     return score\r\n\r\n    private static getNumOccurences(segment:string[], token:string) {\r\n        let numTokens = 0\r\n\r\n        for(let cellIx = 0; cellIx < segment.length; cellIx++) {\r\n//            console.log('cell:' + segment[cellIx])\r\n            if(segment[cellIx] == token) {\r\n                numTokens += 1\r\n            } \r\n        }\r\n\r\n//        console.log('numTokens:' + numTokens)\r\n        return numTokens\r\n    }\r\n\r\n    // return evaluate score of the given board for the maximizerToken\r\n    public static evaluateBoardFor(board:string[][], maximizerToken:string) {\r\n        //TODO\r\n        let score = 0\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n//        console.log(segments)\r\n\r\n        let playerId = ''\r\n        if (maximizerToken != '') {\r\n            playerId = maximizerToken\r\n        } else {\r\n            //TODO HERE\r\n            playerId = 'X'   \r\n        }\r\n\r\n        let opponentId = (playerId == 'X') ? 'O' : 'X'\r\n        for(let segment of segments) {\r\n            const numPlayer = Util.getNumOccurences(segment, playerId)\r\n            const numOpponent = Util.getNumOccurences(segment, opponentId)\r\n            // console.log('numPlayer:' + numPlayer)\r\n            // console.log('numOpponent:' + numOpponent)\r\n            if (numOpponent == 0) {\r\n                if (numPlayer > 0) {\r\n                    if (numPlayer == 4) {\r\n                        score = 10000\r\n                        break\r\n                    } else {\r\n                        score += numPlayer * numPlayer\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(numPlayer == 0) {\r\n                if (numOpponent > 0) {\r\n                    if(numOpponent == 4) {\r\n                        score = -10000\r\n                        break\r\n                    } else {\r\n                        score -= numOpponent * numOpponent\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return score\r\n    }\r\n\r\n    // return evaluate score of the given board for the maximizerToken\r\n    public static evaluateBoardForV2(board:string[][], maximizerToken:string) {\r\n        //TODO\r\n        let score = 0\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n//        console.log(segments)\r\n\r\n        let playerId = ''\r\n        if (maximizerToken != '') {\r\n            playerId = maximizerToken\r\n        } else {\r\n            //TODO HERE\r\n            playerId = 'X'   \r\n        }\r\n\r\n        let opponentId = (playerId == 'X') ? 'O' : 'X'\r\n        for(let segment of segments) {\r\n            const numPlayer = Util.getNumOccurences(segment, playerId)\r\n            const numOpponent = Util.getNumOccurences(segment, opponentId)\r\n            // console.log('numPlayer:' + numPlayer)\r\n            // console.log('numOpponent:' + numOpponent)\r\n            if (numOpponent == 0) {\r\n                if (numPlayer > 0) {\r\n                    if (numPlayer == 4) {\r\n                        score = 10000\r\n                        break\r\n                    }\r\n                    else if (numPlayer == 3) {\r\n                        score += 50\r\n                    }\r\n                    else {\r\n                        score += numPlayer * numPlayer\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(numPlayer == 0) {\r\n                if (numOpponent > 0) {\r\n                    if(numOpponent == 4) {\r\n                        score = -10000\r\n                        break\r\n                    } else {\r\n                        score -= numOpponent * numOpponent\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return score\r\n    }\r\n\r\n    // def segment_board(board):\r\n    // '''\r\n    // returns list of 4-cell segments in the given board, in horizontal, vertical and diagonally\r\n    // '''\r\n    // segments = []\r\n    // # todo\r\n    // scanlines = scan_board(board)\r\n    // for scanline in scanlines:\r\n    //     if len(scanline) >= 4:\r\n    //         for i in range(len(scanline)-3):\r\n    //             segment = []\r\n    //             segment.append(scanline[i])\r\n    //             segment.append(scanline[i+1])\r\n    //             segment.append(scanline[i+2])\r\n    //             segment.append(scanline[i+3])\r\n    //             segments.append(segment)\r\n    // return segments\r\n\r\n    private static segmentBoard(board:string[][]) {\r\n        const segments = []\r\n        const scanLines = Util.scanBoard(board)\r\n//        console.log(scanLines)\r\n\r\n        for(let scanLine of scanLines) {\r\n            if(scanLine.length >= 4) {\r\n                for(let i = 0; i < scanLine.length - 3; i++) {\r\n                    const segment = []\r\n                    segment.push(scanLine[i])\r\n                    segment.push(scanLine[i+1])\r\n                    segment.push(scanLine[i+2])\r\n                    segment.push(scanLine[i+3])\r\n                    segments.push(segment)\r\n                }\r\n            }\r\n        }\r\n        return segments\r\n    }\r\n\r\n    // def scan_board(board):\r\n    // scan_lines = []\r\n    // # left to right\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 0, 0, 1))\r\n    \r\n    // # top to bottom\r\n    // for col in range(7):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, 0))\r\n    \r\n    // # topleft to bottomright\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 0, 1, 1))\r\n    // for col in range(1, 7):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, 1))\r\n\r\n    // # topright to bottomleft\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 6, 1, -1))\r\n    // for col in range(6):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, -1))\r\n    // return scan_lines\r\n    private static scanBoard(board:string[][]) {\r\n        const scanLines = []\r\n\r\n        // # left to right\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 0, 0, 1))\r\n        }\r\n\r\n        // # top to bottom\r\n        for(let col = 0; col < 7; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, 0))\r\n        }\r\n\r\n        // # topleft to bottomright\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 0, 1, 1))\r\n        }\r\n        for(let col = 1; col < 7; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, 1))\r\n        }\r\n\r\n        // # topright to bottomleft\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 6, 1, -1))\r\n        }\r\n        for(let col = 0; col < 6; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, -1))\r\n        }\r\n        return scanLines\r\n    }\r\n/*\r\n    private static segmentBoardWithoutCopy(board:string[][]) {\r\n\r\n        const scanLines = [\r\n            // vertical scan lines\r\n            [board[0][0], board[0][1], board[0][2], board[0][3]],\r\n            [board[0][1], board[0][2], board[0][3], board[0][4]],\r\n            [board[0][2], board[0][3], board[0][4], board[0][5]],\r\n\r\n            [board[1][0], board[1][1], board[1][2], board[1][3]],\r\n            [board[1][1], board[1][2], board[1][3], board[1][4]],\r\n            [board[1][2], board[1][3], board[1][4], board[1][5]],\r\n\r\n            [board[2][0], board[2][1], board[2][2], board[2][3]],\r\n            [board[2][1], board[2][2], board[2][3], board[2][4]],\r\n            [board[2][2], board[2][3], board[2][4], board[2][5]],\r\n\r\n            [board[3][0], board[3][1], board[3][2], board[3][3]],\r\n            [board[3][1], board[3][2], board[3][3], board[3][4]],\r\n            [board[3][2], board[3][3], board[3][4], board[3][5]],\r\n\r\n            [board[4][0], board[4][1], board[4][2], board[4][3]],\r\n            [board[4][1], board[4][2], board[4][3], board[4][4]],\r\n            [board[4][2], board[4][3], board[4][4], board[4][5]],\r\n\r\n            [board[5][0], board[5][1], board[5][2], board[5][3]],\r\n            [board[5][1], board[5][2], board[5][3], board[5][4]],\r\n            [board[5][2], board[5][3], board[5][4], board[5][5]],\r\n\r\n            [board[6][0], board[6][1], board[6][2], board[6][3]],\r\n            [board[6][1], board[6][2], board[6][3], board[6][4]],\r\n            [board[6][2], board[6][3], board[6][4], board[6][5]],\r\n\r\n            // horizontal scan lines\r\n            [board[0][0], board[1][0], board[2][0], board[3][0]],\r\n            [board[1][0], board[2][0], board[3][0], board[4][0]],\r\n            [board[2][0], board[3][0], board[4][0], board[5][0]],\r\n            [board[3][0], board[4][0], board[5][0], board[6][0]],\r\n\r\n            [board[0][1], board[1][1], board[2][1], board[3][1]],\r\n            [board[1][1], board[2][1], board[3][1], board[4][1]],\r\n            [board[2][1], board[3][1], board[4][1], board[5][1]],\r\n            [board[3][1], board[4][1], board[5][1], board[6][1]],\r\n\r\n            [board[0][2], board[1][2], board[2][2], board[3][2]],\r\n            [board[1][2], board[2][2], board[3][2], board[4][2]],\r\n            [board[2][2], board[3][2], board[4][2], board[5][2]],\r\n            [board[3][2], board[4][2], board[5][2], board[6][2]],\r\n\r\n            [board[0][3], board[1][3], board[2][3], board[3][3]],\r\n            [board[1][3], board[2][3], board[3][3], board[4][3]],\r\n            [board[2][3], board[3][3], board[4][3], board[5][3]],\r\n            [board[3][3], board[4][3], board[5][3], board[6][3]],\r\n\r\n            [board[0][4], board[1][4], board[2][4], board[3][4]],\r\n            [board[1][4], board[2][4], board[3][4], board[4][4]],\r\n            [board[2][4], board[3][4], board[4][4], board[5][4]],\r\n            [board[3][4], board[4][4], board[5][4], board[6][4]],\r\n\r\n            [board[0][5], board[1][5], board[2][5], board[3][5]],\r\n            [board[1][5], board[2][5], board[3][5], board[4][5]],\r\n            [board[2][5], board[3][5], board[4][5], board[5][5]],\r\n            [board[3][5], board[4][5], board[5][5], board[6][5]],\r\n\r\n            // diagonal scan lines\r\n            //rising to right\r\n            [board[0][0], board[1][1], board[2][2], board[3][3]],\r\n            [board[0][1], board[1][2], board[2][3], board[3][4]],\r\n            [board[0][2], board[1][3], board[2][4], board[3][5]],\r\n\r\n            [board[1][0], board[2][1], board[3][2], board[4][3]],\r\n            [board[1][1], board[2][2], board[3][3], board[5][4]],\r\n            [board[1][2], board[2][3], board[3][4], board[6][5]],\r\n\r\n            [board[2][0], board[3][1], board[4][2], board[5][3]],\r\n            [board[2][1], board[3][2], board[4][3], board[5][4]],\r\n            [board[2][2], board[3][3], board[4][4], board[5][5]],\r\n\r\n            [board[3][0], board[4][1], board[5][2], board[6][3]],\r\n            [board[3][1], board[4][2], board[5][3], board[6][4]],\r\n            [board[3][2], board[4][3], board[5][4], board[6][5]],\r\n\r\n            //falling to left\r\n            [board[6][0], board[5][1], board[4][2], board[3][3]],\r\n            [board[6][1], board[5][2], board[4][3], board[3][4]],\r\n            [board[6][2], board[5][3], board[4][4], board[3][5]],\r\n\r\n            [board[5][0], board[4][1], board[3][2], board[2][3]],\r\n            [board[5][1], board[4][2], board[3][3], board[2][4]],\r\n            [board[5][2], board[4][3], board[3][4], board[2][5]],\r\n\r\n            [board[4][0], board[3][1], board[2][2], board[1][3]],\r\n            [board[4][1], board[3][2], board[2][3], board[1][4]],\r\n            [board[4][2], board[3][3], board[2][4], board[1][5]],\r\n\r\n            [board[3][0], board[2][1], board[1][2], board[0][3]],\r\n            [board[3][1], board[2][2], board[1][3], board[0][4]],\r\n            [board[3][2], board[2][3], board[1][4], board[0][5]],\r\n        ]\r\n        return scanLines\r\n    }\r\n*/\r\n    // def scan_line(board, startRow, startCol, deltaRow, deltaCol):\r\n    // scan_line = []\r\n\r\n    // scan_line.append(board.get_cell(startRow, startCol))\r\n\r\n    // next_cell_row = startRow + deltaRow\r\n    // next_cell_col = startCol + deltaCol\r\n\r\n    // while next_cell_row < 6 and next_cell_row >= 0 and next_cell_col < 7 and next_cell_col >= 0:\r\n    //     next_cell = board.get_cell(next_cell_row, next_cell_col)\r\n    //     scan_line.append(next_cell)\r\n    //     next_cell_row += deltaRow\r\n    //     next_cell_col += deltaCol\r\n    // return scan_line\r\n    private static scanLine(board:string[][], startRow:number, startCol:number, deltaRow:number, deltaCol:number) {\r\n        const scanLine = []\r\n        scanLine.push(board[startCol][startRow])\r\n\r\n        let nextCellRow = startRow + deltaRow\r\n        let nextCellCol = startCol + deltaCol\r\n        // console.log(board)\r\n\r\n        while(nextCellRow < 6 && nextCellRow >= 0 && nextCellCol < 7 && nextCellCol >= 0) {\r\n            const nextCell = board[nextCellCol][nextCellRow]\r\n            // console.log('nextCellRow:' + nextCellRow)\r\n            // console.log('nextCellCol:' + nextCellCol)\r\n            // console.log(nextCell)\r\n            // console.log('______________________')\r\n            scanLine.push(nextCell)\r\n            nextCellRow += deltaRow\r\n            nextCellCol += deltaCol\r\n        }\r\n        return scanLine\r\n    }\r\n\r\n    // return array of column index for next move given the board\r\n    public static nextMoves(board:string[][]) {\r\n        const columnIxs = []\r\n\r\n        for (let ix = 0; ix < 7; ix++) {\r\n            if (board[ix].indexOf('') > -1) {\r\n                columnIxs.push(ix)\r\n            }\r\n        }\r\n\r\n        return columnIxs\r\n    }\r\n\r\n    // return array of column index for next move given the board\r\n    public static nextMovesReverse(board:string[][]) {\r\n        const columnIxs = []\r\n\r\n        for (let ix = 6; ix >= 0; ix--) {\r\n            if (board[ix].indexOf('') > -1) {\r\n                columnIxs.push(ix)\r\n            }\r\n        }\r\n\r\n        return columnIxs\r\n    }\r\n\r\n    // return array of column index for next move given the board\r\n    public static nextMovesCenterFirst(board:string[][]) {\r\n        const columnIxs = []\r\n\r\n        for (let ix of [3,2,4,1,5,0,6]) {\r\n            if (board[ix].indexOf('') > -1) {\r\n                columnIxs.push(ix)\r\n            }\r\n        }\r\n\r\n        return columnIxs\r\n    }\r\n\r\n    // return True when the game is over\r\n    //        False otherwise\r\n    public static isGameOver(board:string[][]) {\r\n        // console.log('isGameOver()')\r\n        //segment contains four in a row\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n        // console.log('segments:' + segments)\r\n        for(const segment of segments) {\r\n            // console.log('segment:' + segment)\r\n            if(segment[0] == segment[1] && segment[1] == segment[2] &&\r\n                segment[2] == segment[3] && segment[0] != '') {\r\n                // console.log('  returns true with four in a row')\r\n                // Util.dumpBoard(board, 6, 7)\r\n                return true\r\n            }\r\n        }\r\n\r\n        //board is full\r\n        let isFull = true\r\n        for(const column of board) {\r\n            if(column.indexOf('') > -1) {\r\n                isFull = false\r\n            }\r\n        }\r\n\r\n        // console.log('  returns ' + isFull + ' with isFull')\r\n        return isFull\r\n    }\r\n\r\n    public static deepcopyBoard(board:string[][]) {\r\n        const newBoard = []\r\n        for (let i = 0; i < board.length; i++) {\r\n            newBoard[i] = Array.from(board[i])\r\n        }\r\n        return newBoard\r\n    }\r\n\r\n    // return new board with the token on the given column\r\n    public static moveOnBoard(board:string[][], columnIx:number, token:string) {\r\n        const newBoard = Util.deepcopyBoard(board)\r\n\r\n        for(let rowIx = 0; rowIx < 6; rowIx++) {\r\n            if (newBoard[columnIx][rowIx] == '') {\r\n                newBoard[columnIx][rowIx] = token\r\n                break\r\n            }            \r\n        }\r\n\r\n        return newBoard\r\n    }\r\n\r\n    public static moveOnBoardWithoutCopy(board:string[][], columnIx:number, token:string) {\r\n        //const newBoard = Util.deepcopyBoard(board)\r\n\r\n        for(let rowIx = 0; rowIx < 6; rowIx++) {\r\n            if (board[columnIx][rowIx] == '') {\r\n                board[columnIx][rowIx] = token\r\n                break\r\n            }            \r\n        }\r\n\r\n        return board\r\n    }\r\n\r\n    public static unmoveOnBoardWithoutCopy(board:string[][], columnIx:number, token:string) {\r\n        // TODO\r\n        for(let rowIx = 6; rowIx >= 0; rowIx--) {\r\n            if(board[columnIx][rowIx] == token) {\r\n                board[columnIx][rowIx] = ''\r\n                break\r\n            }\r\n        }\r\n        return board\r\n    }\r\n\r\n    // function minimax(node, depth, maximizingPlayer) is\r\n    // if depth = 0 or node is a terminal node then\r\n    //     return the heuristic value of node\r\n    // if maximizingPlayer then\r\n    //     value := −∞\r\n    //     for each child of node do\r\n    //         value := max(value, minimax(child, depth − 1, FALSE))\r\n    //     return value\r\n    // else (* minimizing player *)\r\n    //     value := +∞\r\n    //     for each child of node do\r\n    //         value := min(value, minimax(child, depth − 1, TRUE))\r\n    //     return value\r\n    public static minimax(board:string[][], depth:number, isMaximizer:Boolean, maximizerToken:string, memo:object, stats:any) {\r\n//        console.log(`minimax d:${depth}, isMax:${isMaximizer} maxToken:${maximizerToken}`)\r\n//        Util.dumpBoard(board, board[0].length, board.length)\r\n        let value = 0\r\n        \r\n        // checking memo first\r\n        const key = JSON.stringify(board) + depth\r\n        const val = memo[key]\r\n        if (val !== undefined) {\r\n            value = val\r\n            stats.hitCount++\r\n        }\r\n        else {\r\n            if(depth == 0 || Util.isGameOver(board)) {\r\n                value = Util.evaluateBoardFor(board, maximizerToken)\r\n            }\r\n            else {\r\n                if (isMaximizer) {\r\n                    value = -Infinity\r\n        \r\n                    const nextMoves = Util.nextMoves(board)\r\n                    for (let move of nextMoves) {\r\n                        const newBoard = Util.moveOnBoard(board, move, maximizerToken)\r\n                        const returnValue = Util.minimax(newBoard, depth-1, false, maximizerToken, memo, stats)\r\n                        if (returnValue > value) {\r\n                            value = returnValue\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                else {\r\n                    value = Infinity\r\n        \r\n                    const nextMoves = Util.nextMoves(board)\r\n                    for(let move of nextMoves) {\r\n                        const minimizerToken = (maximizerToken == 'X') ? 'O' : 'X'\r\n                        const newBoard = Util.moveOnBoard(board, move, minimizerToken)\r\n                        const returnValue = Util.minimax(newBoard, depth-1, true, maximizerToken, memo, stats)\r\n                        if(returnValue < value) {\r\n                            value = returnValue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n//        console.log(`return value:${value}`)\r\n        if (val !== value) {\r\n            memo[key] = value\r\n        }\r\n        return value\r\n    }\r\n\r\n    public static minimax_search(board:string[][], depth:number, maximizerToken:string) {\r\n//        console.log(`minimax_search(d:${depth})`)\r\n        let value = -Infinity\r\n        let columnIx = -1\r\n        const memo = {}\r\n        const stats = {\r\n            hitCount: 0\r\n        }\r\n\r\n        const nextMoves = Util.nextMoves(board)\r\n        for (let move of nextMoves) {\r\n            Util.moveOnBoardWithoutCopy(board, move, maximizerToken)\r\n            const returnValue = Util.minimax(board, depth-1, false, maximizerToken, memo, stats)\r\n            Util.unmoveOnBoardWithoutCopy(board, move, maximizerToken)\r\n            if (returnValue > value) {\r\n                value = returnValue\r\n                columnIx = move\r\n            }\r\n        }\r\n//s        console.log(`return value:${columnIx}`)\r\n        // console.log('hitCount:' + stats.hitCount)\r\n        return columnIx\r\n    }\r\n\r\n    public static sortListByMiddle(list:number[]):number[] {\r\n        const newList:number[] = []\r\n        const middleIx = Math.floor((list.length-1)/2)\r\n        newList.push(list[middleIx])\r\n        let leftIx = middleIx-1\r\n        let rightIx = middleIx+1\r\n        while(true) {\r\n            let leftDone = false\r\n            let rightDone = false\r\n\r\n            if(rightIx < list.length) {\r\n                newList.push(list[rightIx])\r\n                rightIx++\r\n            } else {\r\n                rightDone = true\r\n            }\r\n\r\n            if(leftIx >= 0) {\r\n                newList.push(list[leftIx])\r\n                leftIx--\r\n            } else {\r\n                leftDone = true\r\n            }\r\n\r\n            // console.log('leftDone:' + leftDone + ' rightDone:' + rightDone)\r\n\r\n            if(leftDone && rightDone) {\r\n                break\r\n            }\r\n        }\r\n        \r\n        return newList\r\n    }\r\n\r\n    public static sortListByDistanceToColumnIndex3(list:number[]):number[] {\r\n        // let newList:number[] = []\r\n\r\n        // for(const index of list) {\r\n        //     newList.push(Math.abs(index - 3))\r\n        // }\r\n\r\n        // newList.sort((a:number, b:number) => {\r\n        //     return a -b\r\n        // })\r\n\r\n        // console.log(newList)\r\n        // return newList\r\n        let newList:number[] = []\r\n        newList = Array.from(list)\r\n        newList.sort((a:number, b:number) => {\r\n            return Math.abs(a-3) - Math.abs(b-3)\r\n        })\r\n\r\n        // console.log(newList)\r\n        return newList\r\n    }\r\n\r\n    public static alphabeta(board:string[][], depth:number, alpha:number, beta:number,\r\n                            isMaximizingPlayer:Boolean, maximizerId: string, evalFn:any,\r\n                            nextMovesFn:any, copyBoard:boolean, memo:Map<string, number>, stats:any) {\r\n        // console.log(`alphabeta(depth:${depth}, alpha:${alpha}, beta:${beta}, isMax:${isMaximizingPlayer}, maxId:${maximizerId})`)\r\n        // console.log(board)\r\n        let value:any = 0\r\n\r\n        stats.numAlphaBetaCalled++\r\n        if(depth == 0 || Util.isGameOver(board)) {\r\n            const key = Util.stringifyBoard(board, 6, 7)\r\n            if (memo.has(key) === true) {\r\n                value = memo.get(key)\r\n                stats.hitCount++\r\n            }\r\n            else\r\n            {\r\n                value = evalFn(board, maximizerId)\r\n                // console.log('evaluation value:' + value)\r\n                if(value == 10000) {\r\n                    value += depth\r\n                } else if(value == -10000) {\r\n                    value -= depth\r\n                }\r\n                \r\n                if (stats !== null) {\r\n                    stats.numEvals++\r\n                }\r\n\r\n                memo.set(key, value)\r\n            }\r\n        }\r\n        else {\r\n            if(isMaximizingPlayer) {\r\n                value = -Infinity\r\n                const nextMoves = nextMovesFn(board)\r\n                for(const nextMove of nextMoves) {\r\n                    let boardToWorkOn = null\r\n                    if(copyBoard) {\r\n                        boardToWorkOn = Util.moveOnBoard(board, nextMove, maximizerId)\r\n                    } else {\r\n                        boardToWorkOn = Util.moveOnBoardWithoutCopy(board, nextMove, maximizerId)\r\n                    }\r\n    \r\n                    const valueReturned = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, false,\r\n                                            maximizerId, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n    \r\n                    if(copyBoard === false) {\r\n                        Util.unmoveOnBoardWithoutCopy(boardToWorkOn, nextMove, maximizerId)\r\n                    }\r\n    \r\n                    if (valueReturned > value) {\r\n                        value = valueReturned\r\n                    }\r\n    \r\n                    alpha = Math.max(alpha, value)\r\n                    if(alpha >= beta) {\r\n                        // console.log('pruning depth:' + depth + ' move:' + nextMove)\r\n                        break\r\n                    }\r\n                }\r\n            } else {\r\n                value = Infinity\r\n    //            maximizerId = maximizerId == 'X' ? 'O' : 'X'\r\n                const nextMoves = nextMovesFn(board)\r\n                for(const nextMove of nextMoves) {\r\n                    const minimizerId = (maximizerId == 'X' ? 'O' : 'X')\r\n                    let boardToWorkOn = null\r\n                    if(copyBoard) {\r\n                        boardToWorkOn = Util.moveOnBoard(board, nextMove, minimizerId)\r\n                    } else {\r\n                        boardToWorkOn = Util.moveOnBoardWithoutCopy(board, nextMove, minimizerId)\r\n                    }\r\n    \r\n    \r\n                    // console.log('000 loop inside alphabeta')\r\n                    // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n                    \r\n                    const valueReturned = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, true,\r\n                                            maximizerId, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n    \r\n                    if(copyBoard === false) {\r\n                        Util.unmoveOnBoardWithoutCopy(boardToWorkOn, nextMove, minimizerId)\r\n                    }\r\n    \r\n                    // console.log('111 loop inside alphabeta')\r\n                    // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n                    \r\n                    //console.log('move:' + nextMove + ' | valueReturned:' + valueReturned + ' | value:' + value + ' | alpha:' + alpha + ' | beta:' + beta)\r\n    \r\n                    if(valueReturned < value) {\r\n                        value = valueReturned\r\n                    }\r\n    \r\n                    beta = Math.min(beta, value)\r\n                    if(alpha >= beta) {\r\n                        // console.log('pruning depth:' + depth + ' move:' + nextMove)\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }   \r\n        return value\r\n    }\r\n\r\n    public static alphabetaSearch(board:string[][], depth:number, aiToken:string, evalFn:any, nextMovesFn:any, copyBoard:boolean) {\r\n        // console.log('alphabetaSearch')\r\n        let value = -Infinity\r\n        let columnIx = -1\r\n        let alpha = -Infinity\r\n        let beta = Infinity\r\n        const memo = new Map()\r\n        const stats = {\r\n            numEvals: 0,\r\n            hitCount: 0,\r\n            numAlphaBetaCalled: 0,\r\n        }\r\n\r\n        const nextMoves = nextMovesFn(board)\r\n        // console.log('nextmoves.length:' + nextMoves.length)\r\n        let progress = 0\r\n        for(let move of nextMoves) {\r\n\r\n            progress += 100/nextMoves.length\r\n            postMessage({progress:progress})\r\n\r\n            let boardToWorkOn = null\r\n            if (copyBoard) {\r\n                boardToWorkOn = Util.moveOnBoard(board, move, aiToken)\r\n            }\r\n            else {\r\n                boardToWorkOn = Util.moveOnBoardWithoutCopy(board, move, aiToken)                \r\n            }\r\n\r\n            // console.log('000 loop inside alphabetaSearch')\r\n            // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n            \r\n            const returnValue = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, false, aiToken, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n            console.log('returnValue:' + returnValue + ' value:' + value)\r\n\r\n\r\n            if (copyBoard === false) {\r\n                Util.unmoveOnBoardWithoutCopy(boardToWorkOn, move, aiToken)\r\n            }\r\n\r\n            // console.log('111 loop inside alphabetaSearch')\r\n            // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n            \r\n\r\n            if(returnValue > value) {\r\n                value = returnValue\r\n                columnIx = move\r\n            }\r\n\r\n            // console.log('1 columnIx:' + columnIx)\r\n\r\n            alpha = Math.max(alpha, value)\r\n            if(alpha >= beta) {\r\n                // console.log('pruning depth:' + depth + ' move:' + move)\r\n                break\r\n            }\r\n\r\n        }\r\n        // console.log('2 columnIx:' + columnIx)\r\n//        const [, moveToReturn] = Util.alphabeta(board, depth, -Infinity, Infinity, true, aiToken)\r\n        console.log('numAlphaBetaCalled:' + stats.numAlphaBetaCalled)\r\n        console.log('numEvals:' + stats.numEvals)\r\n        console.log('hitCount:' + stats.hitCount)\r\n        return columnIx\r\n    }\r\n\r\n\r\n\r\n    public static aiMove(board:string[][], depth:number, aiToken:string) {\r\n        // console.log('aiMove()')\r\n        // return Util.minimax_search(board, 5, aiToken)\r\n        // console.log('aiDepth:' + depth)\r\n        return Util.alphabetaSearch(board, depth, aiToken, Util.evaluateBoardFor, Util.nextMovesCenterFirst, false)\r\n        // return Util.alphabetaSearch(board, depth, aiToken, Util.evaluateBoardFor, Util.nextMoves, true)\r\n        // return Util.alphabetaSearch(board, depth, aiToken, Util.evaluateBoardFor, Util.nextMovesReverse, true)\r\n    }\r\n}\r\n\r\nexport default Util\n\n\n// WEBPACK FOOTER //\n// ./src/Util.ts"],"sourceRoot":""}