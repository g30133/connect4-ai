{"version":3,"sources":["../webpack/bootstrap 021fbb1b82abc6228075","ai.worker.ts","Util.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","value","__WEBPACK_IMPORTED_MODULE_0__Util__","console","log","addEventListener","event","data","aiColumn","aiMove","board","depth","aiMark","postMessage","colIx","Util","dumpBoard","numRows","numCols","dump","rowIx","checkForWinner","columnWinner","checkColumnsForWinner","rowWinner","checkRowsForWinner","diagonalWinner","checkDiagonalForWinner","winner","_i","board_1","length","column","isBoardFull","board_2","_a","column_1","isValidMove","column_2","getNumOccurences","segment","token","numTokens","cellIx","evaluateBoardFor","maximizerToken","score","segments","segmentBoard","playerId","opponentId","segments_1","numPlayer","numOpponent","evaluateBoardForV2","segments_2","scanLines_1","scanBoard","scanLine","push","scanLines","row","col","startRow","startCol","deltaRow","deltaCol","nextCellRow","nextCellCol","nextCell","nextMoves","columnIxs","ix","indexOf","nextMovesCenterFirst","isGameOver","segments_3","isFull","board_3","deepcopyBoard","newBoard","Array","from","moveOnBoard","columnIx","moveOnBoardWithoutCopy","unmoveOnBoardWithoutCopy","minimax","isMaximizer","memo","stats","key","JSON","stringify","val","undefined","hitCount","Infinity","nextMoves_1","move","returnValue","nextMoves_2","minimizerToken","minimax_search","nextMoves_3","sortListByMiddle","list","newList","middleIx","Math","floor","leftIx","rightIx","leftDone","rightDone","sortListByDistanceToColumnIndex3","sort","a","b","abs","alphabeta","alpha","beta","isMaximizingPlayer","maximizerId","evalFn","nextMovesFn","copyBoard","numEvals","nextMoves_4","nextMove","boardToWorkOn","valueReturned","max","nextMoves_5","minimizerId","min","alphabetaSearch","aiToken","progress","nextMoves_6"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAhB,GACA,IAAAS,EAAAT,KAAAiB,WACA,WAA2B,OAAAjB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,OAAAR,OAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,gBAGAzB,IAAA0B,EAAA,kCC7DAZ,OAAAC,eAAAY,EAAA,cAAAC,OAAA,QAAAC,EAAA7B,EAAA,GAEA8B,QAAQC,IAAI,oBAMZC,iBAAiB,UAAW,SAACC,GACzBH,QAAQC,IAAI,4CACZD,QAAQC,IAAIE,EAAMC,MAClB,IAAMC,EAAWN,EAAA,EAAKO,OAAOH,EAAMC,KAAKG,MAAOJ,EAAMC,KAAKI,MAAOL,EAAMC,KAAKK,QAC5EC,aAAaC,MAAON,oCCZxB,IAAAO,EAAA,oBAAAA,KA65BA,OA55BkBA,EAAAC,UAAd,SAAwBN,EAAkBO,EAAgBC,GAGtD,IADA,IAAIC,EAAc,GACTC,EAAQ,EAAGA,EAAQH,EAASG,IACjC,IAAI,IAAIN,EAAQ,EAAGA,EAAQI,EAASJ,IAChCK,GAAiC,KAAxBT,EAAMI,GAAOM,GAAiB,IAAMV,EAAMI,GAAOM,GACtDN,IAAUI,EAAQ,IAClBC,GAAQ,MAIpBhB,QAAQC,IAAIe,IAGFJ,EAAAM,eAAd,SAA6BX,GAEzB,IAAMY,EAAgBP,EAAKQ,sBAAsBb,GAC3Cc,EAAYT,EAAKU,mBAAmBf,GACpCgB,EAAiBX,EAAKY,uBAAuBjB,GAC/CkB,EAAS,GAQb,MAPoB,KAAjBN,EACCM,EAASN,EACW,KAAdE,EACNI,EAASJ,EACgB,KAAnBE,IACNE,EAASF,GAENE,GAGIb,EAAAQ,sBAAf,SAAqCb,GACjC,IAAoB,IAAAmB,EAAA,EAAAC,EAAApB,EAAAmB,EAAAC,EAAAC,OAAAF,IAChB,IADA,IAAMG,EAAMF,EAAAD,GACJpD,EAAI,EAAGA,EAAIuD,EAAOD,OAAO,EAAGtD,IAChC,GAAGuD,EAAOvD,KAAOuD,EAAOvD,EAAE,IAAMuD,EAAOvD,EAAE,KAAOuD,EAAOvD,EAAE,IAAMuD,EAAOvD,EAAE,KAAOuD,EAAOvD,EAAE,IAAoB,KAAduD,EAAOvD,GAEjG,OAAOuD,EAAOvD,GAI1B,MAAO,IAGIsC,EAAAU,mBAAf,SAAkCf,GAC9B,IAAI,IAAII,EAAQ,EAAGA,EAAQJ,EAAMqB,OAAO,EAAGjB,IACvC,IAAI,IAAIM,EAAQ,EAAGA,EAAQV,EAAMI,GAAOiB,OAAQX,IAC5C,GACIV,EAAMI,GAAOM,KAAWV,EAAMI,EAAM,GAAGM,IACvCV,EAAMI,EAAM,GAAGM,KAAWV,EAAMI,EAAM,GAAGM,IACzCV,EAAMI,EAAM,GAAGM,KAAWV,EAAMI,EAAM,GAAGM,IACjB,KAAxBV,EAAMI,GAAOM,GACT,OAAOV,EAAMI,GAAOM,GAIpC,MAAO,IAGIL,EAAAY,uBAAf,SAAsCjB,GAClC,IAAI,IAAII,EAAQ,EAAGA,EAAQJ,EAAMqB,OAAO,EAAGjB,IAAS,CAChD,IAAI,IAAIM,EAAQ,EAAGA,EAAQV,EAAMI,GAAOiB,OAAO,EAAGX,IAC9C,GAAGV,EAAMI,GAAOM,KAAWV,EAAMI,EAAM,GAAGM,EAAM,IACxCV,EAAMI,EAAM,GAAGM,EAAM,KAAOV,EAAMI,EAAM,GAAGM,EAAM,IACjDV,EAAMI,EAAM,GAAGM,EAAM,KAAOV,EAAMI,EAAM,GAAGM,EAAM,IACzB,KAAxBV,EAAMI,GAAOM,GACjB,OAAOV,EAAMI,GAAOM,GAI5B,IAAQA,EAAQ,EAAGA,EAAQV,EAAMqB,OAAQX,IACrC,GAAGV,EAAMI,GAAOM,KAAWV,EAAMI,EAAM,GAAGM,EAAM,IAChDV,EAAMI,EAAM,GAAGM,EAAM,KAAOV,EAAMI,EAAM,GAAGM,EAAM,IACjDV,EAAMI,EAAM,GAAGM,EAAM,KAAOV,EAAMI,EAAM,GAAGM,EAAM,IACzB,KAAxBV,EAAMI,GAAOM,GACT,OAAOV,EAAMI,GAAOM,GAKhC,MAAO,IAGGL,EAAAkB,YAAd,SAA0BvB,GACtB,IAAoB,IAAAmB,EAAA,EAAAK,EAAAxB,EAAAmB,EAAAK,EAAAH,OAAAF,IAChB,IADA,IACkBM,EAAA,EAAAC,EADNF,EAAAL,GACMM,EAAAC,EAAAL,OAAAI,IAAQ,CACtB,GAAY,KADFC,EAAAD,GACM,OAAO,EAG/B,OAAO,GAGGpB,EAAAsB,YAAd,SAA0BL,GACtB,IAAkB,IAAAH,EAAA,EAAAS,EAAAN,EAAAH,EAAAS,EAAAP,OAAAF,IAAQ,CACtB,GAAY,KADFS,EAAAT,GAGN,OAAO,EAIf,OAAO,GA6DId,EAAAwB,iBAAf,SAAgCC,EAAkBC,GAG9C,IAFA,IAAIC,EAAY,EAERC,EAAS,EAAGA,EAASH,EAAQT,OAAQY,IAEtCH,EAAQG,IAAWF,IAClBC,GAAa,GAKrB,OAAOA,GAIG3B,EAAA6B,iBAAd,SAA+BlC,EAAkBmC,GAgB7C,IAdA,IAAIC,EAAQ,EACNC,EAAWhC,EAAKiC,aAAatC,GAI/BuC,EAAW,GAQXC,EAA0B,MAN1BD,EADkB,IAAlBJ,EACWA,EAGA,KAGsB,IAAM,IACxBhB,EAAA,EAAAsB,EAAAJ,EAAAlB,EAAAsB,EAAApB,OAAAF,IAAU,CAAzB,IAAIW,EAAOW,EAAAtB,GACLuB,EAAYrC,EAAKwB,iBAAiBC,EAASS,GAC3CI,EAActC,EAAKwB,iBAAiBC,EAASU,GAGnD,GAAmB,GAAfG,GACID,EAAY,EAAG,CACf,GAAiB,GAAbA,EAAgB,CAChBN,EAAQ,IACR,MAEAA,GAASM,EAAYA,EAKjC,GAAgB,GAAbA,GACKC,EAAc,EAAG,CACjB,GAAkB,GAAfA,EAAkB,CACjBP,GAAS,IACT,MAEAA,GAASO,EAAcA,GAKvC,OAAOP,GAIG/B,EAAAuC,mBAAd,SAAiC5C,EAAkBmC,GAgB/C,IAdA,IAAIC,EAAQ,EACNC,EAAWhC,EAAKiC,aAAatC,GAI/BuC,EAAW,GAQXC,EAA0B,MAN1BD,EADkB,IAAlBJ,EACWA,EAGA,KAGsB,IAAM,IACxBhB,EAAA,EAAA0B,EAAAR,EAAAlB,EAAA0B,EAAAxB,OAAAF,IAAU,CAAzB,IAAIW,EAAOe,EAAA1B,GACLuB,EAAYrC,EAAKwB,iBAAiBC,EAASS,GAC3CI,EAActC,EAAKwB,iBAAiBC,EAASU,GAGnD,GAAmB,GAAfG,GACID,EAAY,EAAG,CACf,GAAiB,GAAbA,EAAgB,CAChBN,EAAQ,IACR,MAGAA,GADkB,GAAbM,EACI,GAGAA,EAAYA,EAKjC,GAAgB,GAAbA,GACKC,EAAc,EAAG,CACjB,GAAkB,GAAfA,EAAkB,CACjBP,GAAS,IACT,MAEAA,GAASO,EAAcA,GAKvC,OAAOP,GAqBI/B,EAAAiC,aAAf,SAA4BtC,GAKxB,IAJA,IAAMqC,KAIclB,EAAA,EAAA2B,EAHFzC,EAAK0C,UAAU/C,GAGbmB,EAAA2B,EAAAzB,OAAAF,IAAW,CAA3B,IAAI6B,EAAQF,EAAA3B,GACZ,GAAG6B,EAAS3B,QAAU,EAClB,IAAI,IAAItD,EAAI,EAAGA,EAAIiF,EAAS3B,OAAS,EAAGtD,IAAK,CACzC,IAAM+D,KACNA,EAAQmB,KAAKD,EAASjF,IACtB+D,EAAQmB,KAAKD,EAASjF,EAAE,IACxB+D,EAAQmB,KAAKD,EAASjF,EAAE,IACxB+D,EAAQmB,KAAKD,EAASjF,EAAE,IACxBsE,EAASY,KAAKnB,IAI1B,OAAOO,GAyBIhC,EAAA0C,UAAf,SAAyB/C,GAIrB,IAHA,IAAMkD,KAGEC,EAAM,EAAGA,EAAM,EAAGA,IACtBD,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAOmD,EAAK,EAAG,EAAG,IAInD,IAAI,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACtBF,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAO,EAAGoD,EAAK,EAAG,IAInD,IAAQD,EAAM,EAAGA,EAAM,EAAGA,IACtBD,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAOmD,EAAK,EAAG,EAAG,IAEnD,IAAQC,EAAM,EAAGA,EAAM,EAAGA,IACtBF,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAO,EAAGoD,EAAK,EAAG,IAInD,IAAQD,EAAM,EAAGA,EAAM,EAAGA,IACtBD,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAOmD,EAAK,EAAG,GAAI,IAEpD,IAAQC,EAAM,EAAGA,EAAM,EAAGA,IACtBF,EAAUD,KAAK5C,EAAK2C,SAAShD,EAAO,EAAGoD,EAAK,GAAI,IAEpD,OAAOF,GAsHI7C,EAAA2C,SAAf,SAAwBhD,EAAkBqD,EAAiBC,EAAiBC,EAAiBC,GACzF,IAAMR,KACNA,EAASC,KAAKjD,EAAMsD,GAAUD,IAM9B,IAJA,IAAII,EAAcJ,EAAWE,EACzBG,EAAcJ,EAAWE,EAGvBC,EAAc,GAAKA,GAAe,GAAKC,EAAc,GAAKA,GAAe,GAAG,CAC9E,IAAMC,EAAW3D,EAAM0D,GAAaD,GAKpCT,EAASC,KAAKU,GACdF,GAAeF,EACfG,GAAeF,EAEnB,OAAOR,GAIG3C,EAAAuD,UAAd,SAAwB5D,GAGpB,IAFA,IAAM6D,KAEGC,EAAK,EAAGA,EAAK,EAAGA,IACjB9D,EAAM8D,GAAIC,QAAQ,KAAO,GACzBF,EAAUZ,KAAKa,GAIvB,OAAOD,GAIGxD,EAAA2D,qBAAd,SAAmChE,GAG/B,IAFA,IAAM6D,KAES1C,EAAA,EAAAM,GAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAbN,EAAAM,EAAAJ,OAAAF,IAAiB,CAA3B,IAAI2C,EAAErC,EAAAN,GACHnB,EAAM8D,GAAIC,QAAQ,KAAO,GACzBF,EAAUZ,KAAKa,GAIvB,OAAOD,GAKGxD,EAAA4D,WAAd,SAAyBjE,GAMrB,IAHA,IAGqBmB,EAAA,EAAA+C,EAHJ7D,EAAKiC,aAAatC,GAGdmB,EAAA+C,EAAA7C,OAAAF,IAAU,CAA3B,IAAMW,EAAOoC,EAAA/C,GAEb,GAAGW,EAAQ,IAAMA,EAAQ,IAAMA,EAAQ,IAAMA,EAAQ,IACjDA,EAAQ,IAAMA,EAAQ,IAAoB,IAAdA,EAAQ,GAGpC,OAAO,EAMf,IADA,IAAIqC,GAAS,EACO1C,EAAA,EAAA2C,EAAApE,EAAAyB,EAAA2C,EAAA/C,OAAAI,IAAO,CAAX2C,EAAA3C,GACFsC,QAAQ,KAAO,IACrBI,GAAS,GAKjB,OAAOA,GAGG9D,EAAAgE,cAAd,SAA4BrE,GAExB,IADA,IAAMsE,KACGvG,EAAI,EAAGA,EAAIiC,EAAMqB,OAAQtD,IAC9BuG,EAASvG,GAAKwG,MAAMC,KAAKxE,EAAMjC,IAEnC,OAAOuG,GAIGjE,EAAAoE,YAAd,SAA0BzE,EAAkB0E,EAAiB3C,GAGzD,IAFA,IAAMuC,EAAWjE,EAAKgE,cAAcrE,GAE5BU,EAAQ,EAAGA,EAAQ,EAAGA,IAC1B,GAAiC,IAA7B4D,EAASI,GAAUhE,GAAc,CACjC4D,EAASI,GAAUhE,GAASqB,EAC5B,MAIR,OAAOuC,GAGGjE,EAAAsE,uBAAd,SAAqC3E,EAAkB0E,EAAiB3C,GAGpE,IAAI,IAAIrB,EAAQ,EAAGA,EAAQ,EAAGA,IAC1B,GAA8B,IAA1BV,EAAM0E,GAAUhE,GAAc,CAC9BV,EAAM0E,GAAUhE,GAASqB,EACzB,MAIR,OAAO/B,GAGGK,EAAAuE,yBAAd,SAAuC5E,EAAkB0E,EAAiB3C,GAEtE,IAAI,IAAIrB,EAAQ,EAAGA,GAAS,EAAGA,IAC3B,GAAGV,EAAM0E,GAAUhE,IAAUqB,EAAO,CAChC/B,EAAM0E,GAAUhE,GAAS,GACzB,MAGR,OAAOV,GAgBGK,EAAAwE,QAAd,SAAsB7E,EAAkBC,EAAc6E,EAAqB3C,EAAuB4C,EAAaC,GAG3G,IAAIzF,EAAQ,EAGN0F,EAAMC,KAAKC,UAAUnF,GAASC,EAC9BmF,EAAML,EAAKE,GACjB,QAAYI,IAARD,EACA7F,EAAQ6F,EACRJ,EAAMM,gBAGN,GAAY,GAATrF,GAAcI,EAAK4D,WAAWjE,GAC7BT,EAAQc,EAAK6B,iBAAiBlC,EAAOmC,QAGrC,GAAI2C,EAAa,CACbvF,GAASgG,IAGT,IADA,IACiBpE,EAAA,EAAAqE,EADCnF,EAAKuD,UAAU5D,GAChBmB,EAAAqE,EAAAnE,OAAAF,IAAW,CAAvB,IAAIsE,EAAID,EAAArE,GACHmD,EAAWjE,EAAKoE,YAAYzE,EAAOyF,EAAMtD,IACzCuD,EAAcrF,EAAKwE,QAAQP,EAAUrE,EAAM,GAAG,EAAOkC,EAAgB4C,EAAMC,IAC/DzF,IACdA,EAAQmG,QAKf,CACDnG,EAAQgG,IAGR,IADA,IACgB9D,EAAA,EAAAkE,EADEtF,EAAKuD,UAAU5D,GACjByB,EAAAkE,EAAAtE,OAAAI,IAAW,CAAnBgE,EAAIE,EAAAlE,GAAR,IAGMiE,EAFAE,EAAoC,KAAlBzD,EAAyB,IAAM,IACjDmC,EAAWjE,EAAKoE,YAAYzE,EAAOyF,EAAMG,IACzCF,EAAcrF,EAAKwE,QAAQP,EAAUrE,EAAM,GAAG,EAAMkC,EAAgB4C,EAAMC,IAC/DzF,IACbA,EAAQmG,IAU5B,OAHIN,IAAQ7F,IACRwF,EAAKE,GAAO1F,GAETA,GAGGc,EAAAwF,eAAd,SAA6B7F,EAAkBC,EAAckC,GAUzD,IARA,IAAI5C,GAASgG,IACTb,GAAY,EACVK,KACAC,GACFM,SAAU,GAIGnE,EAAA,EAAA2E,EADCzF,EAAKuD,UAAU5D,GAChBmB,EAAA2E,EAAAzE,OAAAF,IAAW,CAAvB,IAAIsE,EAAIK,EAAA3E,GACTd,EAAKsE,uBAAuB3E,EAAOyF,EAAMtD,GACzC,IAAMuD,EAAcrF,EAAKwE,QAAQ7E,EAAOC,EAAM,GAAG,EAAOkC,EAAgB4C,EAAMC,GAC9E3E,EAAKuE,yBAAyB5E,EAAOyF,EAAMtD,GACvCuD,EAAcnG,IACdA,EAAQmG,EACRhB,EAAWe,GAKnB,OADAhG,QAAQC,IAAI,YAAcsF,EAAMM,UACzBZ,GAGGrE,EAAA0F,iBAAd,SAA+BC,GAC3B,IAAMC,KACAC,EAAWC,KAAKC,OAAOJ,EAAK3E,OAAO,GAAG,GAC5C4E,EAAQhD,KAAK+C,EAAKE,IAGlB,IAFA,IAAIG,EAASH,EAAS,EAClBI,EAAUJ,EAAS,IACX,CACR,IAAIK,GAAW,EACXC,GAAY,EAkBhB,GAhBGF,EAAUN,EAAK3E,QACd4E,EAAQhD,KAAK+C,EAAKM,IAClBA,KAEAE,GAAY,EAGbH,GAAU,GACTJ,EAAQhD,KAAK+C,EAAKK,IAClBA,KAEAE,GAAW,EAKZA,GAAYC,EACX,MAIR,OAAOP,GAGG5F,EAAAoG,iCAAd,SAA+CT,GAa3C,IAAIC,KAOJ,OANAA,EAAU1B,MAAMC,KAAKwB,IACbU,KAAK,SAACC,EAAUC,GACpB,OAAOT,KAAKU,IAAIF,EAAE,GAAKR,KAAKU,IAAID,EAAE,KAI/BX,GAGG5F,EAAAyG,UAAd,SAAwB9G,EAAkBC,EAAc8G,EAAcC,EAC9CC,EAA4BC,EAAqBC,EACjDC,EAAiBC,EAAmBtC,EAAaC,GAGrE,IAAIzF,EAAQ,EAEN0F,EAAMC,KAAKC,UAAUnF,GAASC,EAC9BmF,EAAML,EAAKE,GACjB,QAAWI,IAARD,EACC7F,EAAQ6F,EACRJ,EAAMM,gBAGN,GAAY,GAATrF,GAAcI,EAAK4D,WAAWjE,GAGjB,MAFZT,EAAQ4H,EAAOnH,EAAOkH,IAGlB3H,GAASU,GACO,KAAVV,IACNA,GAASU,GAEC,OAAV+E,GACAA,EAAMsC,gBAIV,GAAGL,EAAoB,CACnB1H,GAASgG,IAET,IADA,IACsBpE,EAAA,EAAAoG,EADJH,EAAYpH,GACRmB,EAAAoG,EAAAlG,OAAAF,IAAW,CAA7B,IAAMqG,EAAQD,EAAApG,GACVsG,EAAgB,KAEhBA,EADDJ,EACiBhH,EAAKoE,YAAYzE,EAAOwH,EAAUN,GAElC7G,EAAKsE,uBAAuB3E,EAAOwH,EAAUN,GAGjE,IAAMQ,EAAgBrH,EAAKyG,UAAUW,EAAexH,EAAM,EAAG8G,EAAOC,GAAM,EAClDE,EAAaC,EAAQC,EAAaC,EAAWtC,EAAMC,GAW3E,IATiB,IAAdqC,GACChH,EAAKuE,yBAAyB6C,EAAeD,EAAUN,GAGvDQ,EAAgBnI,IAChBA,EAAQmI,IAGZX,EAAQZ,KAAKwB,IAAIZ,EAAOxH,KACZyH,EAER,WAGL,CACHzH,EAAQgG,IAGR,IADA,IACsB9D,EAAA,EAAAmG,EADJR,EAAYpH,GACRyB,EAAAmG,EAAAvG,OAAAI,IAAW,CAAvB+F,EAAQI,EAAAnG,GAAd,IACMoG,EAA8B,KAAfX,EAAqB,IAAM,IAC5CO,EAAgB,KAEhBA,EADDJ,EACiBhH,EAAKoE,YAAYzE,EAAOwH,EAAUK,GAElCxH,EAAKsE,uBAAuB3E,EAAOwH,EAAUK,GAO3DH,EAAgBrH,EAAKyG,UAAUW,EAAexH,EAAM,EAAG8G,EAAOC,GAAM,EAClDE,EAAaC,EAAQC,EAAaC,EAAWtC,EAAMC,GAgB3E,IAdiB,IAAdqC,GACChH,EAAKuE,yBAAyB6C,EAAeD,EAAUK,GAQxDH,EAAgBnI,IACfA,EAAQmI,GAITX,IADHC,EAAOb,KAAK2B,IAAId,EAAMzH,IAGlB,OASpB,OAHG6F,IAAQ7F,IACPwF,EAAKE,GAAO1F,GAETA,GAGGc,EAAA0H,gBAAd,SAA8B/H,EAAkBC,EAAc+H,EAAgBb,EAAYC,EAAiBC,GAEvG,IAAI9H,GAASgG,IACTb,GAAY,EACZqC,GAASxB,IAEPR,KACAC,GACFsC,SAAU,EACVhC,SAAU,GAGR1B,EAAYwD,EAAYpH,GAC9BP,QAAQC,IAAI,oBAAsBkE,EAAUvC,QAE5C,IADA,IAAI4G,EAAW,EACC9G,EAAA,EAAA+G,EAAAtE,EAAAzC,EAAA+G,EAAA7G,OAAAF,IAAW,CAAvB,IAAIsE,EAAIyC,EAAA/G,GAMR8G,GAAY,IAAIrE,EAAUvC,OAC1BlB,aAAa8H,SAASA,IAEtB,IAAIR,EAAgB,KAEhBA,EADAJ,EACgBhH,EAAKoE,YAAYzE,EAAOyF,EAAMuC,GAG9B3H,EAAKsE,uBAAuB3E,EAAOyF,EAAMuC,GAM7D,IAAMtC,EAAcrF,EAAKyG,UAAUW,EAAexH,EAAM,EAAG8G,EA9BpDxB,KA8BiE,EAAOyC,EAASb,EAAQC,EAAaC,EAAWtC,EAAMC,GAmB9H,IAfkB,IAAdqC,GACAhH,EAAKuE,yBAAyB6C,EAAehC,EAAMuC,GAMpDtC,EAAcnG,IACbA,EAAQmG,EACRhB,EAAWe,IAKfsB,EAAQZ,KAAKwB,IAAIZ,EAAOxH,KAhDjBgG,IAmDH,MAQR,OAFA9F,QAAQC,IAAI,YAAcsF,EAAMsC,UAChC7H,QAAQC,IAAI,YAAcsF,EAAMM,UACzBZ,GAKGrE,EAAAN,OAAd,SAAqBC,EAAkBC,EAAc+H,GAIjD,OAAO3H,EAAK0H,gBAAgB/H,EAAOC,EAAO+H,EAAS3H,EAAK6B,iBAAkB7B,EAAK2D,sBAAsB,IAE7G3D,EA75BA,GA+5Bef,EAAA","file":"021fbb1b82abc6228075.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/connect4-ai/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 021fbb1b82abc6228075","import Util from './Util'\r\n\r\nconsole.log('ai.worker.ts !!!')\r\n\r\n// Post data to parent thread\r\n//postMessage({ foo: 'foo' });\r\n\r\n// Respond to message from parent thread\r\naddEventListener('message', (event) => {\r\n    console.log('worker received message from main thread')\r\n    console.log(event.data)\r\n    const aiColumn = Util.aiMove(event.data.board, event.data.depth, event.data.aiMark)\r\n    postMessage({colIx: aiColumn})\r\n});\n\n\n// WEBPACK FOOTER //\n// ./src/ai.worker.ts","class Util {\r\n    public static dumpBoard(board:string[][], numRows:number, numCols:number) {\r\n        //console.log(`dumpBoard(${board})`)\r\n        let dump:string = ''\r\n        for (let rowIx = 0; rowIx < numRows; rowIx++) {\r\n            for(let colIx = 0; colIx < numCols; colIx++) {\r\n                dump += (board[colIx][rowIx] === '') ? '.' : board[colIx][rowIx]            \r\n                if (colIx === numCols-1) {\r\n                    dump += '\\n'\r\n                }\r\n            }\r\n        }\r\n        console.log(dump)\r\n    }\r\n\r\n    public static checkForWinner(board:string[][]) {\r\n//        console.log('checkForWinner()')\r\n        const columnWinner =  Util.checkColumnsForWinner(board)\r\n        const rowWinner = Util.checkRowsForWinner(board)\r\n        const diagonalWinner = Util.checkDiagonalForWinner(board)\r\n        let winner = ''\r\n        if(columnWinner !== '') {\r\n            winner = columnWinner\r\n        } else if(rowWinner !== '') {\r\n            winner = rowWinner\r\n        } else if(diagonalWinner !== '') {\r\n            winner = diagonalWinner\r\n        }\r\n        return winner\r\n    }\r\n\r\n    private static checkColumnsForWinner(board:string[][]) {\r\n        for(const column of board) {\r\n            for(let i = 0; i < column.length-3; i++) {\r\n                if(column[i] === column[i+1] && column[i+1] === column[i+2] && column[i+2] === column[i+3] && column[i] !== '') {\r\n//                    console.log('column[i]:' + column[i])\r\n                    return column[i]\r\n                }\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    private static checkRowsForWinner(board:string[][]) {\r\n        for(let colIx = 0; colIx < board.length-3; colIx++) {\r\n            for(let rowIx = 0; rowIx < board[colIx].length; rowIx++) {\r\n                if(\r\n                    board[colIx][rowIx] === board[colIx+1][rowIx] &&\r\n                    board[colIx+1][rowIx] === board[colIx+2][rowIx] &&\r\n                    board[colIx+2][rowIx] === board[colIx+3][rowIx] &&\r\n                    board[colIx][rowIx] !== '') {\r\n                        return board[colIx][rowIx]\r\n                    }\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    private static checkDiagonalForWinner(board:string[][]) {\r\n        for(let colIx = 0; colIx < board.length-3; colIx++) {\r\n            for(let rowIx = 0; rowIx < board[colIx].length-3; rowIx++) {\r\n                if(board[colIx][rowIx] === board[colIx+1][rowIx+1] &&\r\n                        board[colIx+1][rowIx+1] === board[colIx+2][rowIx+2] &&\r\n                        board[colIx+2][rowIx+2] === board[colIx+3][rowIx+3] &&\r\n                        board[colIx][rowIx] !== '') {\r\n                    return board[colIx][rowIx]\r\n                }\r\n            }\r\n\r\n            for(let rowIx = 3; rowIx < board.length; rowIx++) {\r\n                if(board[colIx][rowIx] === board[colIx+1][rowIx-1] &&\r\n                board[colIx+1][rowIx-1] === board[colIx+2][rowIx-2] &&\r\n                board[colIx+2][rowIx-2] === board[colIx+3][rowIx-3] &&\r\n                board[colIx][rowIx] !== '') {\r\n                    return board[colIx][rowIx]    \r\n                }\r\n\r\n            }\r\n        }\r\n        return ''\r\n    }\r\n\r\n    public static isBoardFull(board:string[][]) {\r\n        for(const column of board) {\r\n            for(const cell of column) {\r\n                if(cell === '') return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    public static isValidMove(column:string[]) {\r\n        for(const cell of column) {\r\n            if(cell === '') {\r\n//                console.log('isValidMove TRUE')\r\n                return true\r\n            }\r\n        }\r\n//        console.log('isValidMove FALSE')\r\n        return false\r\n    }\r\n\r\n//     def segment_evaluate_v2(board, maximizer_id=0):\r\n//     '''\r\n//     3-in-a-row would give a score of 9, 2 would be 4, 1=1) and if state\r\n//     resulted in 4 in a row it would get a big bonus/punishment of\r\n//     10000/-10000. \r\n//     '''\r\n//     global segment_evaluate_v2_callcount\r\n//     segment_evaluate_v2_callcount += 1\r\n//     score = 0\r\n//     segments = segment_board(board)\r\n\r\n//     player_id = 0\r\n//     if maximizer_id != 0:\r\n//         player_id = maximizer_id\r\n//     else:\r\n//         player_id = board.get_current_player_id()\r\n    \r\n//     opponent_id = 1 if player_id == 2 else 2\r\n\r\n//     #print 'player_id:', player_id\r\n//     #print 'opponent_id:', opponent_id\r\n//     #print segments\r\n// #    print 'seglen:', len(segments)\r\n//     for segment in segments:\r\n// #        print 'seg:', segment\r\n//         num_player = [i for i, x in enumerate(segment) if x == player_id]\r\n//         num_opponent = [i for i, x in enumerate(segment) if x == opponent_id]\r\n//         num_empty = [i for i, x in enumerate(segment) if x == 0]\r\n//         # loop through indexes of segment and push into arrays depending on value\r\n//         # num_empty = [i for i, x in enumerate(segment) if x == 0]\r\n//         # num_x = [i for i, x in enumerate(segment) if x == 1]\r\n//         # num_o = [i for i, x in enumerate(segment) if x == 2]\r\n// #        print 'numx:', num_x\r\n// #        print 'numo:', num_o\r\n// #        print 'nume:', num_empty\r\n// #        print '_______________'\r\n//         if len(num_opponent) == 0:\r\n//             if len(num_player) > 0:\r\n//                 if len(num_player) == 4:\r\n//                    score += 10000\r\n//                 else:\r\n//                     score += len(num_player) * len(num_player)\r\n// #                print 'score:', len(num_x) * len(num_x)\r\n\r\n//         if len(num_player) == 0:\r\n//             if len(num_opponent) > 0:\r\n//                 if len(num_opponent) == 4:\r\n//                     score -= 10000\r\n//                 else:\r\n//                     score -= len(num_opponent) * len(num_opponent)\r\n// #                print 'score:', len(num_o) * len(num_o)\r\n\r\n//     # print 'turn:', board.get_current_player_id()\r\n//     # print board\r\n//     #print 'score:', score\r\n//     # print '_____________________'\r\n//     return score\r\n\r\n    private static getNumOccurences(segment:string[], token:string) {\r\n        let numTokens = 0\r\n\r\n        for(let cellIx = 0; cellIx < segment.length; cellIx++) {\r\n//            console.log('cell:' + segment[cellIx])\r\n            if(segment[cellIx] == token) {\r\n                numTokens += 1\r\n            } \r\n        }\r\n\r\n//        console.log('numTokens:' + numTokens)\r\n        return numTokens\r\n    }\r\n\r\n    // return evaluate score of the given board for the maximizerToken\r\n    public static evaluateBoardFor(board:string[][], maximizerToken:string) {\r\n        //TODO\r\n        let score = 0\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n//        console.log(segments)\r\n\r\n        let playerId = ''\r\n        if (maximizerToken != '') {\r\n            playerId = maximizerToken\r\n        } else {\r\n            //TODO HERE\r\n            playerId = 'X'   \r\n        }\r\n\r\n        let opponentId = (playerId == 'X') ? 'O' : 'X'\r\n        for(let segment of segments) {\r\n            const numPlayer = Util.getNumOccurences(segment, playerId)\r\n            const numOpponent = Util.getNumOccurences(segment, opponentId)\r\n            // console.log('numPlayer:' + numPlayer)\r\n            // console.log('numOpponent:' + numOpponent)\r\n            if (numOpponent == 0) {\r\n                if (numPlayer > 0) {\r\n                    if (numPlayer == 4) {\r\n                        score = 10000\r\n                        break\r\n                    } else {\r\n                        score += numPlayer * numPlayer\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(numPlayer == 0) {\r\n                if (numOpponent > 0) {\r\n                    if(numOpponent == 4) {\r\n                        score = -10000\r\n                        break\r\n                    } else {\r\n                        score -= numOpponent * numOpponent\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return score\r\n    }\r\n\r\n    // return evaluate score of the given board for the maximizerToken\r\n    public static evaluateBoardForV2(board:string[][], maximizerToken:string) {\r\n        //TODO\r\n        let score = 0\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n//        console.log(segments)\r\n\r\n        let playerId = ''\r\n        if (maximizerToken != '') {\r\n            playerId = maximizerToken\r\n        } else {\r\n            //TODO HERE\r\n            playerId = 'X'   \r\n        }\r\n\r\n        let opponentId = (playerId == 'X') ? 'O' : 'X'\r\n        for(let segment of segments) {\r\n            const numPlayer = Util.getNumOccurences(segment, playerId)\r\n            const numOpponent = Util.getNumOccurences(segment, opponentId)\r\n            // console.log('numPlayer:' + numPlayer)\r\n            // console.log('numOpponent:' + numOpponent)\r\n            if (numOpponent == 0) {\r\n                if (numPlayer > 0) {\r\n                    if (numPlayer == 4) {\r\n                        score = 10000\r\n                        break\r\n                    }\r\n                    else if (numPlayer == 3) {\r\n                        score += 50\r\n                    }\r\n                    else {\r\n                        score += numPlayer * numPlayer\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(numPlayer == 0) {\r\n                if (numOpponent > 0) {\r\n                    if(numOpponent == 4) {\r\n                        score = -10000\r\n                        break\r\n                    } else {\r\n                        score -= numOpponent * numOpponent\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return score\r\n    }\r\n\r\n    // def segment_board(board):\r\n    // '''\r\n    // returns list of 4-cell segments in the given board, in horizontal, vertical and diagonally\r\n    // '''\r\n    // segments = []\r\n    // # todo\r\n    // scanlines = scan_board(board)\r\n    // for scanline in scanlines:\r\n    //     if len(scanline) >= 4:\r\n    //         for i in range(len(scanline)-3):\r\n    //             segment = []\r\n    //             segment.append(scanline[i])\r\n    //             segment.append(scanline[i+1])\r\n    //             segment.append(scanline[i+2])\r\n    //             segment.append(scanline[i+3])\r\n    //             segments.append(segment)\r\n    // return segments\r\n\r\n    private static segmentBoard(board:string[][]) {\r\n        const segments = []\r\n        const scanLines = Util.scanBoard(board)\r\n//        console.log(scanLines)\r\n\r\n        for(let scanLine of scanLines) {\r\n            if(scanLine.length >= 4) {\r\n                for(let i = 0; i < scanLine.length - 3; i++) {\r\n                    const segment = []\r\n                    segment.push(scanLine[i])\r\n                    segment.push(scanLine[i+1])\r\n                    segment.push(scanLine[i+2])\r\n                    segment.push(scanLine[i+3])\r\n                    segments.push(segment)\r\n                }\r\n            }\r\n        }\r\n        return segments\r\n    }\r\n\r\n    // def scan_board(board):\r\n    // scan_lines = []\r\n    // # left to right\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 0, 0, 1))\r\n    \r\n    // # top to bottom\r\n    // for col in range(7):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, 0))\r\n    \r\n    // # topleft to bottomright\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 0, 1, 1))\r\n    // for col in range(1, 7):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, 1))\r\n\r\n    // # topright to bottomleft\r\n    // for row in range(6):\r\n    //     scan_lines.append(scan_line(board, row, 6, 1, -1))\r\n    // for col in range(6):\r\n    //     scan_lines.append(scan_line(board, 0, col, 1, -1))\r\n    // return scan_lines\r\n    private static scanBoard(board:string[][]) {\r\n        const scanLines = []\r\n\r\n        // # left to right\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 0, 0, 1))\r\n        }\r\n\r\n        // # top to bottom\r\n        for(let col = 0; col < 7; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, 0))\r\n        }\r\n\r\n        // # topleft to bottomright\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 0, 1, 1))\r\n        }\r\n        for(let col = 1; col < 7; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, 1))\r\n        }\r\n\r\n        // # topright to bottomleft\r\n        for(let row = 0; row < 6; row++) {\r\n            scanLines.push(Util.scanLine(board, row, 6, 1, -1))\r\n        }\r\n        for(let col = 0; col < 6; col++) {\r\n            scanLines.push(Util.scanLine(board, 0, col, 1, -1))\r\n        }\r\n        return scanLines\r\n    }\r\n/*\r\n    private static segmentBoardWithoutCopy(board:string[][]) {\r\n\r\n        const scanLines = [\r\n            // vertical scan lines\r\n            [board[0][0], board[0][1], board[0][2], board[0][3]],\r\n            [board[0][1], board[0][2], board[0][3], board[0][4]],\r\n            [board[0][2], board[0][3], board[0][4], board[0][5]],\r\n\r\n            [board[1][0], board[1][1], board[1][2], board[1][3]],\r\n            [board[1][1], board[1][2], board[1][3], board[1][4]],\r\n            [board[1][2], board[1][3], board[1][4], board[1][5]],\r\n\r\n            [board[2][0], board[2][1], board[2][2], board[2][3]],\r\n            [board[2][1], board[2][2], board[2][3], board[2][4]],\r\n            [board[2][2], board[2][3], board[2][4], board[2][5]],\r\n\r\n            [board[3][0], board[3][1], board[3][2], board[3][3]],\r\n            [board[3][1], board[3][2], board[3][3], board[3][4]],\r\n            [board[3][2], board[3][3], board[3][4], board[3][5]],\r\n\r\n            [board[4][0], board[4][1], board[4][2], board[4][3]],\r\n            [board[4][1], board[4][2], board[4][3], board[4][4]],\r\n            [board[4][2], board[4][3], board[4][4], board[4][5]],\r\n\r\n            [board[5][0], board[5][1], board[5][2], board[5][3]],\r\n            [board[5][1], board[5][2], board[5][3], board[5][4]],\r\n            [board[5][2], board[5][3], board[5][4], board[5][5]],\r\n\r\n            [board[6][0], board[6][1], board[6][2], board[6][3]],\r\n            [board[6][1], board[6][2], board[6][3], board[6][4]],\r\n            [board[6][2], board[6][3], board[6][4], board[6][5]],\r\n\r\n            // horizontal scan lines\r\n            [board[0][0], board[1][0], board[2][0], board[3][0]],\r\n            [board[1][0], board[2][0], board[3][0], board[4][0]],\r\n            [board[2][0], board[3][0], board[4][0], board[5][0]],\r\n            [board[3][0], board[4][0], board[5][0], board[6][0]],\r\n\r\n            [board[0][1], board[1][1], board[2][1], board[3][1]],\r\n            [board[1][1], board[2][1], board[3][1], board[4][1]],\r\n            [board[2][1], board[3][1], board[4][1], board[5][1]],\r\n            [board[3][1], board[4][1], board[5][1], board[6][1]],\r\n\r\n            [board[0][2], board[1][2], board[2][2], board[3][2]],\r\n            [board[1][2], board[2][2], board[3][2], board[4][2]],\r\n            [board[2][2], board[3][2], board[4][2], board[5][2]],\r\n            [board[3][2], board[4][2], board[5][2], board[6][2]],\r\n\r\n            [board[0][3], board[1][3], board[2][3], board[3][3]],\r\n            [board[1][3], board[2][3], board[3][3], board[4][3]],\r\n            [board[2][3], board[3][3], board[4][3], board[5][3]],\r\n            [board[3][3], board[4][3], board[5][3], board[6][3]],\r\n\r\n            [board[0][4], board[1][4], board[2][4], board[3][4]],\r\n            [board[1][4], board[2][4], board[3][4], board[4][4]],\r\n            [board[2][4], board[3][4], board[4][4], board[5][4]],\r\n            [board[3][4], board[4][4], board[5][4], board[6][4]],\r\n\r\n            [board[0][5], board[1][5], board[2][5], board[3][5]],\r\n            [board[1][5], board[2][5], board[3][5], board[4][5]],\r\n            [board[2][5], board[3][5], board[4][5], board[5][5]],\r\n            [board[3][5], board[4][5], board[5][5], board[6][5]],\r\n\r\n            // diagonal scan lines\r\n            //rising to right\r\n            [board[0][0], board[1][1], board[2][2], board[3][3]],\r\n            [board[0][1], board[1][2], board[2][3], board[3][4]],\r\n            [board[0][2], board[1][3], board[2][4], board[3][5]],\r\n\r\n            [board[1][0], board[2][1], board[3][2], board[4][3]],\r\n            [board[1][1], board[2][2], board[3][3], board[5][4]],\r\n            [board[1][2], board[2][3], board[3][4], board[6][5]],\r\n\r\n            [board[2][0], board[3][1], board[4][2], board[5][3]],\r\n            [board[2][1], board[3][2], board[4][3], board[5][4]],\r\n            [board[2][2], board[3][3], board[4][4], board[5][5]],\r\n\r\n            [board[3][0], board[4][1], board[5][2], board[6][3]],\r\n            [board[3][1], board[4][2], board[5][3], board[6][4]],\r\n            [board[3][2], board[4][3], board[5][4], board[6][5]],\r\n\r\n            //falling to left\r\n            [board[6][0], board[5][1], board[4][2], board[3][3]],\r\n            [board[6][1], board[5][2], board[4][3], board[3][4]],\r\n            [board[6][2], board[5][3], board[4][4], board[3][5]],\r\n\r\n            [board[5][0], board[4][1], board[3][2], board[2][3]],\r\n            [board[5][1], board[4][2], board[3][3], board[2][4]],\r\n            [board[5][2], board[4][3], board[3][4], board[2][5]],\r\n\r\n            [board[4][0], board[3][1], board[2][2], board[1][3]],\r\n            [board[4][1], board[3][2], board[2][3], board[1][4]],\r\n            [board[4][2], board[3][3], board[2][4], board[1][5]],\r\n\r\n            [board[3][0], board[2][1], board[1][2], board[0][3]],\r\n            [board[3][1], board[2][2], board[1][3], board[0][4]],\r\n            [board[3][2], board[2][3], board[1][4], board[0][5]],\r\n        ]\r\n        return scanLines\r\n    }\r\n*/\r\n    // def scan_line(board, startRow, startCol, deltaRow, deltaCol):\r\n    // scan_line = []\r\n\r\n    // scan_line.append(board.get_cell(startRow, startCol))\r\n\r\n    // next_cell_row = startRow + deltaRow\r\n    // next_cell_col = startCol + deltaCol\r\n\r\n    // while next_cell_row < 6 and next_cell_row >= 0 and next_cell_col < 7 and next_cell_col >= 0:\r\n    //     next_cell = board.get_cell(next_cell_row, next_cell_col)\r\n    //     scan_line.append(next_cell)\r\n    //     next_cell_row += deltaRow\r\n    //     next_cell_col += deltaCol\r\n    // return scan_line\r\n    private static scanLine(board:string[][], startRow:number, startCol:number, deltaRow:number, deltaCol:number) {\r\n        const scanLine = []\r\n        scanLine.push(board[startCol][startRow])\r\n\r\n        let nextCellRow = startRow + deltaRow\r\n        let nextCellCol = startCol + deltaCol\r\n        // console.log(board)\r\n\r\n        while(nextCellRow < 6 && nextCellRow >= 0 && nextCellCol < 7 && nextCellCol >= 0) {\r\n            const nextCell = board[nextCellCol][nextCellRow]\r\n            // console.log('nextCellRow:' + nextCellRow)\r\n            // console.log('nextCellCol:' + nextCellCol)\r\n            // console.log(nextCell)\r\n            // console.log('______________________')\r\n            scanLine.push(nextCell)\r\n            nextCellRow += deltaRow\r\n            nextCellCol += deltaCol\r\n        }\r\n        return scanLine\r\n    }\r\n\r\n    // return array of column index for next move given the board\r\n    public static nextMoves(board:string[][]) {\r\n        const columnIxs = []\r\n\r\n        for (let ix = 0; ix < 7; ix++) {\r\n            if (board[ix].indexOf('') > -1) {\r\n                columnIxs.push(ix)\r\n            }\r\n        }\r\n\r\n        return columnIxs\r\n    }\r\n\r\n    // return array of column index for next move given the board\r\n    public static nextMovesCenterFirst(board:string[][]) {\r\n        const columnIxs = []\r\n\r\n        for (let ix of [3,2,4,1,5,0,6]) {\r\n            if (board[ix].indexOf('') > -1) {\r\n                columnIxs.push(ix)\r\n            }\r\n        }\r\n\r\n        return columnIxs\r\n    }\r\n\r\n    // return True when the game is over\r\n    //        False otherwise\r\n    public static isGameOver(board:string[][]) {\r\n        // console.log('isGameOver()')\r\n        //segment contains four in a row\r\n        const segments = Util.segmentBoard(board)\r\n        //const segments = Util.segmentBoardWithoutCopy(board)\r\n        // console.log('segments:' + segments)\r\n        for(const segment of segments) {\r\n            // console.log('segment:' + segment)\r\n            if(segment[0] == segment[1] && segment[1] == segment[2] &&\r\n                segment[2] == segment[3] && segment[0] != '') {\r\n                // console.log('  returns true with four in a row')\r\n                // Util.dumpBoard(board, 6, 7)\r\n                return true\r\n            }\r\n        }\r\n\r\n        //board is full\r\n        let isFull = true\r\n        for(const column of board) {\r\n            if(column.indexOf('') > -1) {\r\n                isFull = false\r\n            }\r\n        }\r\n\r\n        // console.log('  returns ' + isFull + ' with isFull')\r\n        return isFull\r\n    }\r\n\r\n    public static deepcopyBoard(board:string[][]) {\r\n        const newBoard = []\r\n        for (let i = 0; i < board.length; i++) {\r\n            newBoard[i] = Array.from(board[i])\r\n        }\r\n        return newBoard\r\n    }\r\n\r\n    // return new board with the token on the given column\r\n    public static moveOnBoard(board:string[][], columnIx:number, token:string) {\r\n        const newBoard = Util.deepcopyBoard(board)\r\n\r\n        for(let rowIx = 0; rowIx < 6; rowIx++) {\r\n            if (newBoard[columnIx][rowIx] == '') {\r\n                newBoard[columnIx][rowIx] = token\r\n                break\r\n            }            \r\n        }\r\n\r\n        return newBoard\r\n    }\r\n\r\n    public static moveOnBoardWithoutCopy(board:string[][], columnIx:number, token:string) {\r\n        //const newBoard = Util.deepcopyBoard(board)\r\n\r\n        for(let rowIx = 0; rowIx < 6; rowIx++) {\r\n            if (board[columnIx][rowIx] == '') {\r\n                board[columnIx][rowIx] = token\r\n                break\r\n            }            \r\n        }\r\n\r\n        return board\r\n    }\r\n\r\n    public static unmoveOnBoardWithoutCopy(board:string[][], columnIx:number, token:string) {\r\n        // TODO\r\n        for(let rowIx = 6; rowIx >= 0; rowIx--) {\r\n            if(board[columnIx][rowIx] == token) {\r\n                board[columnIx][rowIx] = ''\r\n                break\r\n            }\r\n        }\r\n        return board\r\n    }\r\n\r\n    // function minimax(node, depth, maximizingPlayer) is\r\n    // if depth = 0 or node is a terminal node then\r\n    //     return the heuristic value of node\r\n    // if maximizingPlayer then\r\n    //     value := −∞\r\n    //     for each child of node do\r\n    //         value := max(value, minimax(child, depth − 1, FALSE))\r\n    //     return value\r\n    // else (* minimizing player *)\r\n    //     value := +∞\r\n    //     for each child of node do\r\n    //         value := min(value, minimax(child, depth − 1, TRUE))\r\n    //     return value\r\n    public static minimax(board:string[][], depth:number, isMaximizer:Boolean, maximizerToken:string, memo:object, stats:any) {\r\n//        console.log(`minimax d:${depth}, isMax:${isMaximizer} maxToken:${maximizerToken}`)\r\n//        Util.dumpBoard(board, board[0].length, board.length)\r\n        let value = 0\r\n        \r\n        // checking memo first\r\n        const key = JSON.stringify(board) + depth\r\n        const val = memo[key]\r\n        if (val !== undefined) {\r\n            value = val\r\n            stats.hitCount++\r\n        }\r\n        else {\r\n            if(depth == 0 || Util.isGameOver(board)) {\r\n                value = Util.evaluateBoardFor(board, maximizerToken)\r\n            }\r\n            else {\r\n                if (isMaximizer) {\r\n                    value = -Infinity\r\n        \r\n                    const nextMoves = Util.nextMoves(board)\r\n                    for (let move of nextMoves) {\r\n                        const newBoard = Util.moveOnBoard(board, move, maximizerToken)\r\n                        const returnValue = Util.minimax(newBoard, depth-1, false, maximizerToken, memo, stats)\r\n                        if (returnValue > value) {\r\n                            value = returnValue\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                else {\r\n                    value = Infinity\r\n        \r\n                    const nextMoves = Util.nextMoves(board)\r\n                    for(let move of nextMoves) {\r\n                        const minimizerToken = (maximizerToken == 'X') ? 'O' : 'X'\r\n                        const newBoard = Util.moveOnBoard(board, move, minimizerToken)\r\n                        const returnValue = Util.minimax(newBoard, depth-1, true, maximizerToken, memo, stats)\r\n                        if(returnValue < value) {\r\n                            value = returnValue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n//        console.log(`return value:${value}`)\r\n        if (val !== value) {\r\n            memo[key] = value\r\n        }\r\n        return value\r\n    }\r\n\r\n    public static minimax_search(board:string[][], depth:number, maximizerToken:string) {\r\n//        console.log(`minimax_search(d:${depth})`)\r\n        let value = -Infinity\r\n        let columnIx = -1\r\n        const memo = {}\r\n        const stats = {\r\n            hitCount: 0\r\n        }\r\n\r\n        const nextMoves = Util.nextMoves(board)\r\n        for (let move of nextMoves) {\r\n            Util.moveOnBoardWithoutCopy(board, move, maximizerToken)\r\n            const returnValue = Util.minimax(board, depth-1, false, maximizerToken, memo, stats)\r\n            Util.unmoveOnBoardWithoutCopy(board, move, maximizerToken)\r\n            if (returnValue > value) {\r\n                value = returnValue\r\n                columnIx = move\r\n            }\r\n        }\r\n//s        console.log(`return value:${columnIx}`)\r\n        console.log('hitCount:' + stats.hitCount)\r\n        return columnIx\r\n    }\r\n\r\n    public static sortListByMiddle(list:number[]):number[] {\r\n        const newList:number[] = []\r\n        const middleIx = Math.floor((list.length-1)/2)\r\n        newList.push(list[middleIx])\r\n        let leftIx = middleIx-1\r\n        let rightIx = middleIx+1\r\n        while(true) {\r\n            let leftDone = false\r\n            let rightDone = false\r\n\r\n            if(rightIx < list.length) {\r\n                newList.push(list[rightIx])\r\n                rightIx++\r\n            } else {\r\n                rightDone = true\r\n            }\r\n\r\n            if(leftIx >= 0) {\r\n                newList.push(list[leftIx])\r\n                leftIx--\r\n            } else {\r\n                leftDone = true\r\n            }\r\n\r\n            // console.log('leftDone:' + leftDone + ' rightDone:' + rightDone)\r\n\r\n            if(leftDone && rightDone) {\r\n                break\r\n            }\r\n        }\r\n        \r\n        return newList\r\n    }\r\n\r\n    public static sortListByDistanceToColumnIndex3(list:number[]):number[] {\r\n        // let newList:number[] = []\r\n\r\n        // for(const index of list) {\r\n        //     newList.push(Math.abs(index - 3))\r\n        // }\r\n\r\n        // newList.sort((a:number, b:number) => {\r\n        //     return a -b\r\n        // })\r\n\r\n        // console.log(newList)\r\n        // return newList\r\n        let newList:number[] = []\r\n        newList = Array.from(list)\r\n        newList.sort((a:number, b:number) => {\r\n            return Math.abs(a-3) - Math.abs(b-3)\r\n        })\r\n\r\n        // console.log(newList)\r\n        return newList\r\n    }\r\n\r\n    public static alphabeta(board:string[][], depth:number, alpha:number, beta:number,\r\n                            isMaximizingPlayer:Boolean, maximizerId: string, evalFn:any,\r\n                            nextMovesFn:any, copyBoard:boolean, memo:object, stats:any) {\r\n        // console.log(`alphabeta(depth:${depth}, alpha:${alpha}, beta:${beta}, isMax:${isMaximizingPlayer}, maxId:${maximizerId})`)\r\n        // console.log(board)\r\n        let value = 0\r\n\r\n        const key = JSON.stringify(board) + depth\r\n        const val = memo[key]\r\n        if(val !== undefined) {\r\n            value = val\r\n            stats.hitCount++\r\n        }\r\n        else {\r\n            if(depth == 0 || Util.isGameOver(board)) {\r\n                value = evalFn(board, maximizerId)\r\n                // console.log('evaluation value:' + value)\r\n                if(value == 10000) {\r\n                    value += depth\r\n                } else if(value == -10000) {\r\n                    value -= depth\r\n                }\r\n                if (stats !== null) {\r\n                    stats.numEvals++\r\n                }\r\n            }\r\n            else {\r\n                if(isMaximizingPlayer) {\r\n                    value = -Infinity\r\n                    const nextMoves = nextMovesFn(board)\r\n                    for(const nextMove of nextMoves) {\r\n                        let boardToWorkOn = null\r\n                        if(copyBoard) {\r\n                            boardToWorkOn = Util.moveOnBoard(board, nextMove, maximizerId)\r\n                        } else {\r\n                            boardToWorkOn = Util.moveOnBoardWithoutCopy(board, nextMove, maximizerId)\r\n                        }\r\n        \r\n                        const valueReturned = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, false,\r\n                                                maximizerId, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n        \r\n                        if(copyBoard === false) {\r\n                            Util.unmoveOnBoardWithoutCopy(boardToWorkOn, nextMove, maximizerId)\r\n                        }\r\n        \r\n                        if (valueReturned > value) {\r\n                            value = valueReturned\r\n                        }\r\n        \r\n                        alpha = Math.max(alpha, value)\r\n                        if(alpha >= beta) {\r\n                            // console.log('pruning depth:' + depth + ' move:' + nextMove)\r\n                            break\r\n                        }\r\n                    }\r\n                } else {\r\n                    value = Infinity\r\n        //            maximizerId = maximizerId == 'X' ? 'O' : 'X'\r\n                    const nextMoves = nextMovesFn(board)\r\n                    for(const nextMove of nextMoves) {\r\n                        const minimizerId = (maximizerId == 'X' ? 'O' : 'X')\r\n                        let boardToWorkOn = null\r\n                        if(copyBoard) {\r\n                            boardToWorkOn = Util.moveOnBoard(board, nextMove, minimizerId)\r\n                        } else {\r\n                            boardToWorkOn = Util.moveOnBoardWithoutCopy(board, nextMove, minimizerId)\r\n                        }\r\n        \r\n        \r\n                        // console.log('000 loop inside alphabeta')\r\n                        // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n                        \r\n                        const valueReturned = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, true,\r\n                                                maximizerId, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n        \r\n                        if(copyBoard === false) {\r\n                            Util.unmoveOnBoardWithoutCopy(boardToWorkOn, nextMove, minimizerId)\r\n                        }\r\n        \r\n                        // console.log('111 loop inside alphabeta')\r\n                        // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n                        \r\n                        //console.log('move:' + nextMove + ' | valueReturned:' + valueReturned + ' | value:' + value + ' | alpha:' + alpha + ' | beta:' + beta)\r\n        \r\n                        if(valueReturned < value) {\r\n                            value = valueReturned\r\n                        }\r\n        \r\n                        beta = Math.min(beta, value)\r\n                        if(alpha >= beta) {\r\n                            // console.log('pruning depth:' + depth + ' move:' + nextMove)\r\n                            break\r\n                        }\r\n                    }    \r\n                }\r\n            }   \r\n        }\r\n        if(val !== value) {\r\n            memo[key] = value\r\n        }\r\n        return value\r\n    }\r\n\r\n    public static alphabetaSearch(board:string[][], depth:number, aiToken:string, evalFn:any, nextMovesFn:any, copyBoard:boolean) {\r\n        // console.log('alphabetaSearch')\r\n        let value = -Infinity\r\n        let columnIx = -1\r\n        let alpha = -Infinity\r\n        let beta = Infinity\r\n        const memo = {}\r\n        const stats = {\r\n            numEvals: 0,\r\n            hitCount: 0\r\n        }\r\n\r\n        const nextMoves = nextMovesFn(board)\r\n        console.log('nextmoves.length:' + nextMoves.length)\r\n        let progress = 0\r\n        for(let move of nextMoves) {\r\n\r\n            // const progressBar:HTMLProgressElement|null = document.querySelector('.aiprogress')\r\n            // if (progressBar) {\r\n            //     progressBar.value += 100/(nextMoves.length)\r\n            // }\r\n            progress += 100/nextMoves.length\r\n            postMessage({progress:progress})\r\n\r\n            let boardToWorkOn = null\r\n            if (copyBoard) {\r\n                boardToWorkOn = Util.moveOnBoard(board, move, aiToken)\r\n            }\r\n            else {\r\n                boardToWorkOn = Util.moveOnBoardWithoutCopy(board, move, aiToken)                \r\n            }\r\n\r\n            // console.log('000 loop inside alphabetaSearch')\r\n            // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n            \r\n            const returnValue = Util.alphabeta(boardToWorkOn, depth-1, alpha, beta, false, aiToken, evalFn, nextMovesFn, copyBoard, memo, stats)\r\n            // console.log('returnValue:' + returnValue + ' value:' + value)\r\n\r\n\r\n            if (copyBoard === false) {\r\n                Util.unmoveOnBoardWithoutCopy(boardToWorkOn, move, aiToken)\r\n            }\r\n\r\n            // console.log('111 loop inside alphabetaSearch')\r\n            // Util.dumpBoard(boardToWorkOn, 6, 7)\r\n\r\n            if(returnValue > value) {\r\n                value = returnValue\r\n                columnIx = move\r\n            }\r\n\r\n            // console.log('1 columnIx:' + columnIx)\r\n\r\n            alpha = Math.max(alpha, value)\r\n            if(alpha >= beta) {\r\n                // console.log('pruning depth:' + depth + ' move:' + move)\r\n                break\r\n            }\r\n\r\n        }\r\n        // console.log('2 columnIx:' + columnIx)\r\n//        const [, moveToReturn] = Util.alphabeta(board, depth, -Infinity, Infinity, true, aiToken)\r\n        console.log('numEvals:' + stats.numEvals)\r\n        console.log('hitCount:' + stats.hitCount)\r\n        return columnIx\r\n    }\r\n\r\n\r\n\r\n    public static aiMove(board:string[][], depth:number, aiToken:string) {\r\n        // console.log('aiMove()')\r\n        // return Util.minimax_search(board, 5, aiToken)\r\n        // console.log('aiDepth:' + depth)\r\n        return Util.alphabetaSearch(board, depth, aiToken, Util.evaluateBoardFor, Util.nextMovesCenterFirst, false)\r\n    }\r\n}\r\n\r\nexport default Util\n\n\n// WEBPACK FOOTER //\n// ./src/Util.ts"],"sourceRoot":""}